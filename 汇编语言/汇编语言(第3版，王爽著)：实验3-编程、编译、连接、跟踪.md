![实验3](./汇编语言(第3版，王爽著)：实验3-编程、编译、连接、跟踪.assets/17731575-2889a7f99715fe5d.png)

### 1. 将上图所示的程序保存为 t1.asm 文件，将其生成可执行文件 t1.exe。
#### （1） 汇编程序从写出到执行的过程：
![汇编程序从写出到执行的过程](./汇编语言(第3版，王爽著)：实验3-编程、编译、连接、跟踪.assets/17731575-6de1ab0c5d6ea321.png)

#### （2） 编辑
可以使用任意的文本编辑器来编辑源程序，只要最终将其存储为纯文本文件即可。
> 文本编辑器：
> （1） 前面的文章配置 Debug 环境时，提到过的执行文件 Edit
> ![Edit](./汇编语言(第3版，王爽著)：实验3-编程、编译、连接、跟踪.assets/17731575-5505c0d27aa815e8.png)
> （2） VSCode
> ······

#### （3） 编译
> **功能：**
> 可以对文本文件进行编译，生成包含“机器代码”的目标文件（将 t1.asm 编译成为 t1.obj）。
> 使用微软的 masm5.0 汇编编译器，文件名为 **masm.exe**

编译方法一：（繁杂的方式，包含可看到的中间文件）
![编译方法一](./汇编语言(第3版，王爽著)：实验3-编程、编译、连接、跟踪.assets/17731575-ee129a8b2c1e7715.png)

编译方法二：（简化的方式，忽略编译过程产生的中间文件）
![编译方法二](./汇编语言(第3版，王爽著)：实验3-编程、编译、连接、跟踪.assets/17731575-bca6cf3986b95726.png)

经过编译，就可以看到产生的目标文件 T1.OBJ

#### （4） 连接
> **功能：**
> 对目标文件进行连接，从而得到可执行文件（将 t1.obj 连接成为 t1.exe）。
> 使用微软的 Overlay Linker3.60 连接器，文件名为 **link.exe**

连接方法一：（繁杂的方式，包含可看到的中间文件）
![连接方法一](./汇编语言(第3版，王爽著)：实验3-编程、编译、连接、跟踪.assets/17731575-9c013f06bbdcb16e.png)

连接方法二：（简化的方式，忽略连接过程产生的中间文件）
![连接方法二](./汇编语言(第3版，王爽著)：实验3-编程、编译、连接、跟踪.assets/17731575-6f640aa7c5769ef1.png)

> **连接的作用：**
> （1） 当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用“连接程序”将它们连接到一起，生成一个可执行文件；
> （2） 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；
> （3） 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，“连接程序”将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用“连接程序”对目标文件进行处理，生成可执行文件。

经过连接，就可以看到产生的可执行文件 T1.EXE

### 2. 用 Debug 跟踪 t1.exe 的执行过程，写出每一步执行后，相关寄存器中的内容和栈顶的内容。

![程序执行过程的跟踪.png](./汇编语言(第3版，王爽著)：实验3-编程、编译、连接、跟踪.assets/17731575-b3ce2ee1b44f883f.png)


执行过程寄存器中的内容和栈顶的内容就不写出来了。

### 3. PSP 的头两个字节是 CD 20，用 Debug 加载 t1.exe，查看 PSP 的内容。
用 Debug 加载 t1.exe 后，PSP 在内存中的地址：见上面一张图

![查看 PSP 的内容](./汇编语言(第3版，王爽著)：实验3-编程、编译、连接、跟踪.assets/17731575-3e16d238fa86c587.png)
