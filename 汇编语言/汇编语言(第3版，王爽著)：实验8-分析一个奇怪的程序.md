![分析一个奇怪的程序](./汇编语言(第3版，王爽著)：实验8-分析一个奇怪的程序.assets/17731575-704c4f3c472fdc3a.png)

#### 1. 分析下面的程序，在运行前思考：这个程序可以正确返回吗？
> 在程序运行前，我个人的思考结果是不会返回，好像进入了死循环（说明我在看第九章的时候不仔细(─.─||)）

#### 2. 运行后再思考：为什么是这种结果？
> 先说结论：运行后，程序可以正确返回

代码讲解：
> mov di, offset s
> mov si, offset s2
> mov ax, cs:[si]
> mov cs:[di], ax
> 1. 以上代码的作用就是将 “标号s2” 处的数据(即机器指令) 复制到 “标号s” 处
> 2. 从下图可以看出，“标号s2” 处的机器指令为 **EBF6**，因此当上面的那几句代码执行完后，“标号s” 处的机器指令为 **EBF6**
> 3. 因为“标号s2”处的汇编指令为 jmp short s，所以这是一个 “依据位移进行转移的 jmp 指令”，所对应的机器码中包含的是转移的位移，并不是转移的目的地址
> 4. 不要因为“标号s2”处的汇编指令为 jmp short s，就想当然的认为将 jmp short s 复制到了 “标号s” 处，这种想法是错误的
> 5. 可以看到下图是在调试的时候用 debug 去调试的，展示“机器指令”和“汇编指令”是用 **U** 命令去转换的，本质上计算机只能存储二进制数据，所以操作的也是二进制数据，即 CPU 操作的是二进制数据 **EBF6**
> 6. CPU 在执行 **EBF6** 的时候，根据什么修改的 IP寄存器？使其指向目标指令呢？就是根据指令中的 **F6** （提示：**F6** 是补码），即 CPU 执行 **EBF6** 时，当前的 **(IP)** 加上 **F6**，就得出了新的 **(IP)**，也就完成了**新的指向**
> - 6.1 标号s2 处汇编指令的讲解
> ![实验8 标号s2 处汇编指令的讲解](./汇编语言(第3版，王爽著)：实验8-分析一个奇怪的程序.assets/17731575-052a682da852e22a.png)
> - 6.2 标号s 处汇编指令的讲解
> ![实验8 标号s 处汇编指令的讲解](./汇编语言(第3版，王爽著)：实验8-分析一个奇怪的程序.assets/17731575-98243d32cf332ca3.png)
> - 6.3 如果对于代码还有疑问，请看 《汇编语言 (第3版)》王爽著，第 179 页，关于 CPU 执行机器指令时，是如何修改 IP 寄存器的。



![实验8 调试过程](./汇编语言(第3版，王爽著)：实验8-分析一个奇怪的程序.assets/17731575-6fff5d1ad9005e6e.png)
